
## IPXTransporter – Friendly Project Overview (Markdown)

> *You’re about to build* `IPXTransporter`, a high‑performance, mesh‑based IPX traffic monitor that supports a terminal UI, a web UI, and a rich test harness.

---

### 1.  Architecture Overview

- **Capture Layer** – uses libpcap to sniff raw IPX packets on a chosen interface and pushes them into a Go channel.
- **Router** – a single goroutine that pulls packets from the capture channel, deduplicates them, and forwards them to all connected peers.
- **Peer** – each remote instance of the daemon establishes a TLS connection to every other peer. Inside each TLS connection a bidirectional Gob encoder/decoder streams packets.
- **Terminal UI (TUI)** – a separate, non‑blocking goroutine that consumes a *read‑only* statistics view exposed by the router.
- **Web UI (HTTP)** – optional; serves JSON statistics and an SVG diagram generated by Graphviz.

---

### 2.  Packet Model

```go
type Packet struct {
    Timestamp time.Time // time the packet was captured
    Size      int        // payload size in bytes
    Source    string     // human‑readable source (e.g. "node1:port")
    Destination string   // human‑readable destination (e.g. "node2:port")
    SrcIPX    string     // IPX Net/Node/Sock
    DstIPX    string     // IPX Net/Node/Sock
}
```

The router maintains a *deduplication ring buffer* of size 64 k.  
Each packet is hashed by `(srcIPX+dstIPX+socket)` and compared against the ring.  
If a hash is found the packet is dropped; otherwise it is appended to the ring and forwarded.

---

### 3.  Capture Layer

The capture module calls `pcap.OpenLive` on the specified interface and sets a BPF filter that accepts only IPX packets:

```
type Capture struct {
    handle *pcap.Handle
    ch     chan<- Packet
}

func (c *Capture) CaptureLoop(iface string, ch chan<- Packet) {
    h, _ := pcap.OpenLive(iface, 65535, true, pcap.BlockForever)
    h.SetBPFFilter("ipx")
    defer h.Close()
    packetSource := gopacket.NewPacketSource(h, h.LinkType())
    for packet := range packetSource.Packets() {
        pkt := parsePacket(packet)
        ch <- pkt
    }
}
```

`parsePacket` extracts the IPX header, timestamps the packet, and returns a `Packet` struct.

---

### 4.  Router

```go
type Router struct {
    inbound  <-chan Packet
    peers    map[string]*Peer
    mu       sync.RWMutex
    dupRing  *ring.Ring
    dupHits  int64
}

func NewRouter(in <-chan Packet) *Router {
    r := &Router{inbound: in, peers: make(map[string]*Peer)}
    go r.forward()
    return r
}

func (r *Router) forward() {
    for pkt := range r.inbound {
        if r.isDuplicate(pkt) { continue }
        r.mu.RLock()
        for _, p := range r.peers {
            p.incoming <- pkt
        }
        r.mu.RUnlock()
    }
}
```

`isDuplicate` hashes the packet and checks the ring buffer.  
The router owns a `inbound` channel of size 1000 and a per‑peer `incoming` channel of size 1000.

---

### 5.  Peer

```go
type Peer struct {
    id          string
    conn        net.Conn
    outgoing    chan<- Packet
    incoming    <-chan Packet
    sentBytes   int64
    recvBytes   int64
}

func (p *Peer) sender() {
    enc := gob.NewEncoder(p.conn)
    for pkt := range p.incoming {
        enc.Encode(pkt)
        atomic.AddInt64(&p.sentBytes, int64(pkt.Size))
    }
}

func (p *Peer) receiver() {
    dec := gob.NewDecoder(p.conn)
    for {
        var pkt Packet
        if err := dec.Decode(&pkt); err != nil { return }
        atomic.AddInt64(&p.recvBytes, int64(pkt.Size))
        p.incoming <- pkt
    }
}
```

---

### 6.  Handshake / Gossip

The first packet exchanged on a new TLS connection is a **handshake**:

```go
type Handshake struct {
    Version   string   // "1.0"
    PeerID    string   // e.g. "node‑01"
    Capabilities []string // e.g. ["dedup", "gossip"]
}

func (p *Peer) initHandshake() {
    dec := gob.NewDecoder(p.conn)
    var hs Handshake
    dec.Decode(&hs)
    if hs.Version != "1.0" { /* reject */ }
    p.id = hs.PeerID
}
```

Peers subsequently exchange **gossip** packets every `gossip_interval`:

```go
type Gossip struct {
    Status map[string]string // peerID → "online"/"offline"
    Timestamp time.Time
}
```

The router merges gossip into its `peers` map.  A peer is marked “offline” if no gossip has been received within `gossip_timeout`.

---

### 7. Web UI (HTTP) Implementation

The optional HTTP server is a thin wrapper around the TUI’s statistics data.  
It exposes two endpoints:

1. `GET /stats` – Returns a JSON payload that mirrors the TUI data structure.
2. `GET /diagram` – Returns an SVG representation of the peer graph.

```go
// StatsHandler implements the /stats endpoint.
func StatsHandler(w http.ResponseWriter, r *http.Request) {
    if token := r.Header.Get("X‑Auth‑Token"); token != "" && token != cfg.Web.Token {
        http.Error(w, "Unauthorized", http.StatusUnauthorized)
        return
    }
    data := router.GetStats() // returns map[string]interface{}
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(data)
}
```

```go
// DiagramHandler implements the /diagram endpoint.
func DiagramHandler(w http.ResponseWriter, r *http.Request) {
    if token := r.Header.Get("X‑Auth‑Token"); token != "" && token != cfg.Web.Token {
        http.Error(w, "Could not generate diagram", http.StatusInternalServerError)
        return
    }
    svg, err := diagram.GenerateSVG(router.GetPeerGraph())
    if err != nil {
        http.Error(w, "Could not generate diagram", http.StatusInternalServerError)
        return
    }
    w.Header().Set("Content-Type", "image/svg+xml")
    w.Write(svg)
}
```

Both handlers perform a simple token‑based authentication by inspecting the `X‑Auth‑Token` header.  
If the token is missing or incorrect, the handlers return a `401 Unauthorized` or `500 Internal Server Error` respectively.  
The `json.NewEncoder` call in `StatsHandler` streams the statistics JSON directly to the client, while `DiagramHandler` captures the SVG byte slice produced by the Graphviz `dot` utility and writes it to the response with the appropriate MIME type.

---

### 8. Testing Strategy (Extremely Verbose)

The test suite is divided into **three** categories:

1. **Unit Tests** – Verify isolated logic without external dependencies.
   * `capture_test.go` – mocks pcap packets and checks that the capture layer correctly parses and tags them.
   * `router_test.go` – uses an in‑memory TLS listener (`net.Pipe`) to simulate peer connections; asserts that packets are forwarded and that deduplication works.
   * `protocol_test.go` – marshals and unmarshals handshake/gossip JSON and ensures validation passes/fails as expected.

2. **Integration Tests** – Spin up two or more daemon instances in a Docker‑Compose network.
   * Each container runs `IPXTransporter` with a unique `name` and connects to the other via TLS.
   * Tests send a burst of synthetic IPX packets from one container and verify that the other receives them after a maximum delay of 200 ms.
   * They also test handshakes across network namespaces and verify that gossip keeps the status map synchronized.

3. **End‑to‑End Tests** – Use a real Linux host with a physical network.
   * A **mock peer** written in Go listens on a TCP port, performs a TLS handshake, and logs all packets it receives.
   * The daemon is started with `--disable-ssl` to allow a plain TCP connection.
   * The test script connects to the daemon, sends a packet, and verifies the mock peer receives it.

#### Mock Peer Implementation

```go
func mockPeer(t *testing.T, addr string, out chan<- Packet) {
    ln, err := tls.Listen("tcp", addr, tlsConfig)
    if err != nil { t.Fatalf("listen failed: %v", err) }

    go func() {
        for {
            conn, err := ln.Accept()
            if err != nil { break }
            // Perform handshake, then read packets
            dec := gob.NewDecoder(conn)
            var pkt Packet
            if err := dec.Decode(&pkt); err != nil { continue }
            out <- pkt
        }
    }()
}
```

This mock peer logs all packets to the `out` channel, enabling the test harness to assert correct traffic flow.

#### Performance Tests

* `dedup_test.go` – inserts 1 million packets and checks that the deduplication ring buffer still reports correct hit/miss counts.
* `router_perf_test.go` – measures packets per second (pps) under a sustained load of 5 000 pps and ensures the daemon does not drop packets.

#### CI Pipeline

```yaml
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      docker:
        image: docker:20.10.8
        options: --privileged
    steps:
      - uses: actions/checkout@v2
      - name: Install Go
        uses: actions/setup-go@v2
        with:
          go-version: '1.19'
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y graphviz
      - name: Run tests
        run: go test ./... -coverprofile=coverage.out
      - name: Upload coverage
        uses: codecov/codecov-action@v2
```

The test suite also includes a **race detector** check (`go test -race`) to ensure there are no data races in the router logic.

---

### 9. Build and Release Process

The daemon is built using `go build` with the following tags:

```bash
go build -ldflags="-s -w" -trimpath -o bin/ipxtransporter ./cmd/ipxtransporter
```

* `-s -w` strips debug information for a smaller binary.
* The resulting binary is **standalone** and requires only the Go runtime and Graphviz (if web UI is enabled).

#### Packaging

* **Debian Package** – `debian/ipxtransporter_1.0.0_amd64.deb`
   * Installs binary to `/usr/local/bin` and config file to `/etc`.
   * Provides `systemd` service file that automatically starts the daemon on boot.
* **Red‑Hat RPM** – `RHEL/ipxtransporter-1.0.0-1.x86_64.rpm`

Both packages include:

```
/usr/lib/ipxtransporter/ipxtransporter.service
```

The systemd unit file:

```
[Unit]
Description=IPXTransporter Daemon
After=network.target

[Service]
ExecStart=/usr/local/bin/ipxtransporter --mode=server
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
```

---

### 10. FAQ (Frequently Asked Questions)

| Question | Answer |
|----------|--------|
| **Can I run the daemon on non‑Linux systems?** | The capture layer relies on `pcap` and the Linux `rawip` interface. On macOS you can use `libpcap` with a custom BPF filter; on Windows the capture layer is not yet supported. |
| **Is there a way to use a central discovery service instead of gossip?** | Yes – implement a simple WebSocket server that peers can subscribe to. The daemon already exposes a `GetPeerGraph` method that can be wired to such a service. |
| **How do I upgrade a running instance without dropping connections?** | Deploy the new binary, then trigger `systemctl restart ipxtransporter`. The `systemd` service will kill the old process after a 10‑second graceful shutdown, giving peers time to reconnect. |
| **What if I need to monitor a very high traffic network (100 000 pps)?** | Increase `gossip_interval` and `gossip_timeout` to reduce overhead. Tune the router’s inbound/outbound buffer sizes and adjust the deduplication ring buffer size. Use a multi‑core system and enable Go’s `GOMAXPROCS` accordingly. |
| **Is there support for IPv6?** | The IPX addresses are represented as 3‑byte NetID, 3‑byte NodeID, and 1‑byte Socket. IPv6 is irrelevant for IPX; the daemon does not use IPX to communicate with peers – only the TLS layer uses IPv4 or IPv6 addresses. |
| **How secure is the TLS layer?** | The daemon uses TLS 1.3 by default, with a randomly generated self‑signed certificate if none is supplied. Peer certificates can be verified by providing a CA bundle. All configuration values are sanitized to avoid injection attacks. |

---

### 11. Makefile (Optional)

```make
.PHONY: all clean test dist

all: ipxtransporter

ipxtransporter:
	@go build -o bin/ipxtransporter -ldflags="-s -w" ./cmd/ipxtransporter

test:
	@go test ./... -v

dist: clean
	@mkdir -p dist
	@go build -o dist/ipxtransporter -ldflags="-s -w" ./cmd/ipxtransporter
	@cp config/example.json dist/
```

---

### 12. Sample Docker‑Compose Setup

```yaml
version: "3.8"

services:
  ipx-01:
    image: ghcr.io/yourorg/ipxtransporter:latest
    container_name: ipx-01
    network_mode: bridge
    command: --mode=server
    ports:
      - "9000:9000"
      - "8080:8080"

  ipx-02:
    image: ghcr.io/yourorg/ipxtransporter:latest
    container_name: ipx-02
    network_mode: bridge
    command: --mode=server
    ports:
      - "9001:9000"
```

---

### 13. How to Run the Daemon

```bash
# 1. Install dependencies
sudo apt-get install -y graphviz libpcap0.8-dev

# 2. Build the binary
go build -o ipxtransporter ./cmd/ipxtransporter

# 3. Create a config file (optional)
cat <<'EOF' > /etc/ipxtransporter.json
{
  "interface": "eth0",
  "port": 9000,
  "log_level": "info",
  "web": {
    "enable": true,
    "port": 8080,
    "token": "super-secret"
  },
  "gossip_interval": "10s",
  "gossip_timeout": "30s"
}
EOF

# 4. Start the daemon
sudo ./ipxtransporter --mode=server

# 5. (Optional) Connect a peer manually
telnet 192.168.1.5 9000
# It will perform a TLS handshake automatically.
```

The daemon will automatically detect and connect to any other instances on the same network that are listening on the same port.

---

### 14. Final Notes

* The design intentionally avoids a central server; all peers form a **peer‑to‑peer** mesh.
* The TUI is fully reactive and updates at a high refresh rate without blocking packet routing.
* The web UI is safe: it serves only from `localhost` and requires an optional token for authentication.
* The code is licensed under the MIT License, allowing commercial use with minimal restrictions.

**Enjoy monitoring your IPX network!**